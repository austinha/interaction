---
layout: presentation
title: Lab 03 Managing State in Response to Events --Week 3, Thursday--
description: Introduction to state management in Android
class: middle, center, inverse
---
name: inverse
layout: true
class: center, middle, inverse
---
template: inverse

# Interactivity Lab (Fall 2018)
## Week 3: State; Event Handling

Instructor: TBD
_{email}_

Slides online: xxxTODO url

---
layout: false

# Goals for Today

---
layout: false

# Goals for Today

- Understand more about __Event Handling__

- Understanding more about __Activities__
--

- State & Data Persistence (Part 1)

--

- Finite State Machine Exercise

---
template: inverse

## Event Handling

???
- Implementation strategy

- Basic goal: notify the view of a change


---
# Basics of Event Listeners (1/3)

- Interface on the `View` class that acts as a _callback_ method

--

- Must be attached to a particular `View`

--

- Android framework triggers the method once the `View` has interacted with by the user

--

- A `View` can have listen for different types of interactions
- But: the `View` must implement and registering the appropriate listeners

---

# Basics of Event Listeners (2/2)

- The set of Android's provided interfaces include:
  ```java
    // User tapped a view
    public static interface View.OnClickListener { ... }

    // User long pressed on a View
    public static interface View.OnLongClickListener { ... }

    // State of view has changed
    // (e.g. user clicked outside a EditText input box)
    public static interface View.OnFocusChangeListener { ... }
  ```
  More listed in the API Documentation (https://developer.android.com/guide/topics/ui/ui-events.html)
---

# Declaring an Event Listener
- Two ways to use declare an event listener:

  - Create an Anonymous Class

  - Implement an Interface

---
## Create an Anonymous Class
```java
  public class ExampleActivity extends AppCompatActivity {

    private Button mButton;
    private int mButtonClicks = 0;

    // As a member variable in an Activity
    private View.OnClickListener mClickListener = new View.OnClickListener() {
      public void OnClick(View v) {
        if (mButton != v) {
          // Do nothing if its not the right view
          return;
        }
        // Increment the click count
        mButtonClicks += 1;
      }
    };

    protected void onCreate(Bundle savedState) {
      Button mButton = (Button) findViewById(R.id.button_test);
      if (mButton != null) {
        // 'this' refers to the activity itself here
        // When the button clicked, Android will trigger
        // the Activity's OnClick method
        mButton.setOnClickListener(mClickListener);
      }
    }
  }
```
---
## Implement the Interface
  ```java
    // Start by implementing the interface
    public class ExampleActivity extends AppCompatActivity
      implements View.OnClickListener { // Necessary to implement

      private Button mButton;
      private int mButtonClicks = 0;

      protected void onCreate(Bundle savedState) {
        Button mButton = (Button) findViewById(R.id.button_test);
        if (mButton != null) {
          // 'this' refers to the activity itself here
          // When the button clicked, Android will trigger
          // the Activity's OnClick method
          mButton.setOnClickListener(this);
        }
      }

      // Here's where you do the implementation of your listener
      public void OnClick(View v) {
        if (mButton != v) {
          // Do nothing if its not the right view
          return;
        }
        // Increment the click count
        mButtonClicks += 1;
      }

    }
  ```
---

# Registering a Listener (1/2)

- Once a listener is created
  ```java
    View.OnClickListener buttonListener = new View.OnClickListener({
      public void OnClick(View v) {
        if (mButton != v) {
          // Do nothing if its not the right view
          return;
        }
        // Increment the click count
        mButtonClicks += 1;
      }
    });
  ```

--

- Set it on the view:
  ```java
    Button mButton = (Button) findViewById(R.id.button_test);
    if (mButton != null) {
      mButton.setOnClickListener(buttonListener);
    }
  ```
---
# Registering a Listener (2/2)

- `View` has a series of `set*Listeners(...)`, for example:
  ```java
  View v = new View();
  v.setOnClickListener(...);
  v.setLongClickListener(...);
  ```
---
# Marking an event as handled
- Many listeners return a `boolean` value that indicate the event has been handled
  ```java
    /**
     * onLongClick - triggered when a view is long clicked
     * @param v - the view long pressed
     * @return - true if the callback consumed the long click, false otherwise.
     **/
    boolean onLongClick (View v) { ... };
  ```
--

- Returning `false` causes the event to bubble up to the next possible view that can handle it



[API Documentation for Long Click](https://developer.android.com/reference/android/view/View.OnLongClickListener.html)
---

## Many Views, Same Listener (1/3)

- Event callbacks are passed the `View` as a parameter

--

- We can reuse a listener for views that handle the same action
  (e.g. 3 buttons increment the same click count)

---

## Many Views, Same Listener (2/3)

- And we can handle different actions by checking the `View` or its `id`:
  ```java
    protected void onCreate(Bundle savedState) {
      Button mButtonOne = (Button) findViewById(R.id.button_one);
      if (mButtonOne != null) {
        mButtonOne.setOnClickListener(mButtonClickListener);
      }

      Button mButtonTwo = (Button) findViewById(R.id.button_two);
      if (mButtonTwo != null) {
        mButton.setOnClickListener(mButtonClickListener);
      }
    }
  ```
---
## Many Views, Same Listener (3/3)

```java
  View.OnClickListener mButtonClickListener = new View.OnClickListener({
    public void OnClick(View v) {
      if (v == null) {
        return;
      }

      int viewId = v.getId();

      switch (viewId) {
        case R.id.button_one:
          // First Button
          Log.d("Button Press", "First Button");
          break;
        case R.id.button_two:
          // Second Button
          Log.d("Button Press", "Second Button");
          break;
        default:
          // Someone else is using the listener!
          Log.d("Button Press", "Invalid Button!");

      }
    }
  });
```
---
# How Android Triggers Listeners

- Android traverses the view hierarchy (starting at root)

--

- "Picks" `Views` that respond to an input event

--

- Loops through the list of `View` objects, checks if they will "capture" the event

--

- If none capture the event, the event "bubbles" back up the `View` object list

---
# More on Listeners

- Different views can have different handlers

--

    - `ListView`: `onItemClick`
    - Context menus from long clicks: `onCreateContextMenu`
    - Keystrokes: `onKey`
    - And others...

--

- Check documentation for specifics

---
# Types of Input

- Not just touches, clicks, key presses

--

- *Sensors* - GPS, IMU/Accelerometer, humidity, temperature, etc

???
Sampled or event based?
--
  - `Managers` (e.g. `LocationManager`) let us create and register a listener

  - Listeners can receive updates at different intervals, etc.

  - Some Sensor-specific settings  
    https://source.android.com/devices/sensors/sensor-types.html

---
# Other Kinds of Input

- Microphone

- Camera

- Multi-touch

- Connected Devices?
---

# Exercise

- XXXTODO CHECK CODE in Lab-Exercises/Puppy-Event-Handling XXXX Pair up! - Base Code (http://shoutkey.com/come)

- Using listeners, when the pup is clicked, increment a petting count

- When long clicked, show a `Toast` saying "that tickles!" (but don't increment the count !)

.center.quarter-width-img[
  ![Animated Pet app](img/pet-pupper-app.gif)
]

---
template: inverse

# Saving State
---

.left-column[## Activity Lifecycle]
.right-column[![:img Android activity lifecycle, 50%](img/activity_lifecycle.png)]


---

.left-column[## When to save state? (1/3)]
.right-column[![:img Android activity state diagram, 50%](img/android-activity-states-01.png)]


---

.left-column[## When to save state? (2/3)]
.right-column[![:img Android activity state diagram -- process killed, 50%](img/android-activity-states-02.png)]

---

.left-column[# When to save state? (3/3)]
.right-column[
- Activity `A` spawns Activity `B`
  - E.g. Typing a Facebook post, then you select 'Add a Location'
]
--
.right-column[
- Android kills `A` to reclaim resources while the user is interacting with `B`
]
--
.right-column[
- User finishes with `B`, returns to `A` but the post is gone!
]
---

# Maintaining Activity State

- We can fix it by saving the state in a `Bundle` before Android closes the `Activity`

- We then restore the state when we return to the `Activity` later

---

# Bundle it up

- `Bundle`: A hash map (dictionary) of String keys to Primitive, Parcelable, Serializable values

--

- Used to:
  (1) Save/restore state
  (2) Transfer data between different `Activity` in an app

--

- Primitive are `int`, `float`, `boolean`, `double` (the usual suspects)

--

- Custom objects that implement the `Serializable` or `Parcelable` interfaces
  - You will need to make any custom classes that you want to save into a `Bundle` implement the `Parcelable` interface

---

# Parcelable vs. Serializable

- Both are for the same purpose of saving but `Serializable` makes implementations much easier...

--

- **EXCEPT, .red[you should almost always use `Parcelable`]**


--

- Why?
  - `Serializable` uses introspection ==> more memory, and CPU cycles
  - `Parcelable` **is optimized for mobile devices**

---
## Implementing `Parcelable` (1/3)

-- You are required to implement the following methods for the `Parcelable` interface:

```java
public class MyPersonModel implements Parcelable {
    private int mAge;

    // Required for the interface
    public int describeContents() {
        return 0;
    }

    // Required for the interface
    public void writeToParcel(Parcel out, int flags) {
        out.writeInt(mAge);
    }
    // Continued on next slide...
```

---

## Implementing `Parcelable` (2/3)

```java

    // Required for the interface
    // CREATOR is an object that can remark
    public static final Parcelable.Creator<MyPersonModel> CREATOR
            = new Parcelable.Creator<MyPersonModel>() {
        public MyPersonModel createFromParcel(Parcel in) {
            return new MyPersonModel(in);
        }

        public MyPersonModel[] newArray(int size) {
            return new MyPersonModel[size];
        }
    };

    // Required for the interface
    // Private constructor for Android to use with your CREATOR
    private MyPersonModel(Parcel in) {
        mAge = in.readInt();
    }
}
```
---

## Implementing `Parcelable` (3/3)
- **Note**: .red[the order of the values when writing and reading them matters!]

  - When you write to the parcel using `write*()` methods in `writeToParcel`,

  - The write order __MUST BE__ the same as when you read them in the private constructor

- For more details on implementation:
  https://developer.android.com/reference/android/os/Parcelable.html

---

# Saving in the Bundle

- Methods for _saving_ items out of a Bundle

  - Ints: `putInt(String key, int value)`

  - Floats: `putFloat(String key, float value)`

  - Characters: `putChar(String key, char value)`

  - Strings: `putString(String key, String value)`

  - Serializable Objects: `putSerializable(String key, Serializable value)`

  - Parcelable Objects: `putParcelable(String key, Parcelable value)`

  - _Others in the documentation (e.g. Arrays, Bytes, etc).._
    https://developer.android.com/reference/android/os/Bundle.html

---
# Retrieving from the Bundle

- Methods for getting items out of a Bundle

  - Ints: `getInt(String key)`

  - Floats: `getFloat(String key)`

  - Characters: `getChar(String key)`

  - Strings: `getString(String key)`

  - Serializable Objects: `getSerializable(String key)`

  - Parcelable Objects: `getParcelable(String key)`

  - _Others in the documentation_ (e.g. Arrays, Bytes, etc)..
    https://developer.android.com/reference/android/os/Bundle.html
---
## Saving Activity State (1/3)
- Android provides the `onSaveInstanceState(Bundle savedInstanceState)` callback method for you to save the state of an `Activity`

```java
private static final USERNAME_KEY = "USER_NAME_KEY";
private static final FIB_SUM_KEY = "FIB_SUM_KEY";

private int mFibSumValue; // Set to 10295 by our user
private String mUsername; // Set to "Michael" by our user

@Override
public void onSaveInstanceState(Bundle outState) {
    // Always call super - your super classes could be saving state for you!
    super.onSaveInstanceState(outState);

    // Now
    outState.putInt(FIB_SUM_KEY, mFibSumValue);
    outState.putString(USERNAME_KEY, mUsername);
}
```
---

## Restoring Activity State (1/4)

- We saved, and now our user goes off to some other app

--

- Android kills our `Activity`

--

- Now how do we get the _saved_ state back?

---
## Restoring Activity State (2/4)

-  Two ways:
  - `onCreate(Bundle savedInstanceState)`
  - `onRestoreInstanceState(Bundle savedInstanceState)`

---
## Restoring Activity State (3/4)

- Using `onCreate(Bundle savedInstanceState)`...

```java
private static final USERNAME_KEY = "USER_NAME_KEY";
private static final FIB_SUM_KEY = "FIB_SUM_KEY";

private int mFibSumValue = 0;
private String mUsername = null;

@Override
protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);

  mMainTextView = (TextView) findViewById(R.id.text_main_title);
  mSumTextView = (TextView) findViewById(R.id.text_sum);
  // Check if there was a previously saved state to restore to the user
  // A non-null bundle means there was a state that was saved previously
  // A bundle is just a Key-Value pairing - its a hash map :)
  if (savedInstanceState != null) {
    // There was a previous state - time to restore
    mFibSumValue = savedInstanceState.getInt(FIB_SUM_KEY);
    mUsername = savedInstanceState.getString(USERNAME_KEY);
  }
  updateMainText();
  updateFibSumText();
}
```

---

## Restoring Activity State (4/4)

- Using `onRestoreInstanceState(Bundle savedInstanceState)`

```java
private static final USERNAME_KEY = "USER_NAME_KEY";
private static final FIB_SUM_KEY = "FIB_SUM_KEY";
private int mFibSumValue = 0;

@Override
protected void onRestoreInstanceState(Bundle savedInstanceState) {
  super.onRestoreInstanceState(savedInstanceState);
  // Check if there was a previously saved state to restore to the user
  if (savedInstanceState != null) {
    // There was a previous state - time to restore
    mFibSumValue = savedInstanceState.getInt(FIB_SUM_KEY);
    mUsername = savedInstanceState.getString(USERNAME_KEY);
  }
  updateMainText();
  updateFibSumText();
}
```

---

### Restoring in `onCreate` vs. `onRestoreInstanceState`
- `onRestoreInstanceState`
  - Guarantees you will never have a non-null `Bundle` when called
  - Lets subclasses override the behavior of restoring the state

- `onCreate`
  - Lets you focus on doing all of your initialization in one place

- You decide what works best for you :)

- http://stackoverflow.com/questions/36408776/using-oncreate-vs-onrestoreinstancestate

---

## Exercise: Parcelable and Activity State

- Pair up!

- Download the base code here:

- This app lets a user enter a name, age, and favorite food

- It stores this info in a `PersonModel`

- When the app is killed, this information needs to remain edited

- Implement the `Parcelable` interface for the PersonModel

- Then use the Activity's relevant state change callbacks to `PersonModel` when the phone rotates

---
### Some Notes about `onSaveInstanceState()`
- .red[Only use to save and restore session variables and the state of the UI]

--

  - Android won't always trigger the method

--

  - It is called when the `Activity` is closed and _expected_ to be restored soon

--

- If your app crashes, or is closed, **the values in the bundle will disappear!**

--

- If you use custom views, you can implement their version of `onSaveInstanceState`:

  Android will call `onSaveInstanceState()` every view in the layout

---
# Project Work: Add Save State


---
# End of Slides
    
---

